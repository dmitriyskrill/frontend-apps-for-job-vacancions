[
  {
    "type": "p",
    "text": "Есть массив объектов, которые имеют поля id и parent, через которые их можно связать в дерево и некоторые произвольные поля. id может быть как числом, так и строкой. Порядок id не гарантируется, изначально отсутствует какой либо принцип сортировки. Поле type не влияет ни на что, просто отображает возможность наличия какой-то полезной нагрузки в айтемах. "
  },
  {
    "type": "p",
    "text": "НУЖНО написать класс, который принимает в конструктор массив этих объектов и реализует следующие методы:"
  },
  {
    "type": "list",
    "header": "При нажатии на кнопку вызова лифт должен обработать этот вызов в соответствии со следующими сценариями:",
    "listItems": [
      " - getAll() Должен возвращать изначальный массив элементов.",
      " - getItem(id) Принимает id элемента и возвращает сам объект элемента;",
      " - getChildren(id) Принимает id элемента и возвращает массив элементов, являющихся дочерними для того элемента чей id получен в аргументе. Если у элемента нет дочерних, то должен возвращаться пустой массив;",
      " - getAllChildren(id) Принимает id элемента и возвращает массив элементов, являющихся прямыми дочерними элементами того, Принимает id элемента и возвращает массив элементов, являющихся прямыми дочерними элементами того, Принимает id элемента и возвращает массив элементов, являющихся прямыми дочерними элементами того,",
      " - getAllParents(id) Принимает id элемента и возвращает массив из цепочки родительских элементов, начиная от самого элемента, чей id был передан в аргументе и до корневого элемента,  т.е. должен получиться путь элемента наверх дерева через цепочку родителей к корню дерева. ",
      " - в результате getAllParents ПОРЯДОК ЭЛЕМЕНТОВ ВАЖЕН!"
    ]
  },
  {
    "type": "p",
    "text": "ТРЕБОВАНИЕ: максимальное быстродействие, следовательно, минимальное количество обходов массива при операциях, \n * в идеале, прямой доступ к элементам без поиска их в массиве."
  },
  {
    "type": "p",
    "text": " ПЛЮСАМИ будет:\n *  - написание этого класса на TypeScript\n *  - написание тестов для функционала методов"
  }
]